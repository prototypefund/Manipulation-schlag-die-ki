<app>

    <script>
        let app = this;


        app.showInfoScreen = function(tag, opts, resolveOn){
            return new Promise((resolve, reject) => {
                let mounted = null;
                opts = opts || {};
                opts[resolveOn] = () => {mounted.unmount(true); resolve(arguments)};
                mounted = riot.mount(tag, opts)[0];
            });
        };

        app.loadData = async function(data){
            const spinner = riot.mount("spinner")[0];
            const dataLoaded = await preloadAssets(data);
            spinner.unmount(true);
            return dataLoaded;
        };

        app.initChallenge = function(data) {

            const obj = {};

            obj.CLEAN_IMAGE_TIMEOUT = 30*1000; // how long image without any perturbation is shown
            obj.PERTURBATION_TIMEOUT = 300;     // how long image with perturbation is shown

            // todo loading screen
            obj.loadData = async function(){
                obj.data = await data;
            };

            obj.showAnswers = function(){
                obj.answers = {};
                obj.answers.opts = {answers: obj.data.answers, correct: obj.data.correct, disabled: true, onselected: () => {}};
                obj.answers.mount = riot.mount("answers", obj.answers.opts)[0];
            };

            obj.showImage = function(perturbation){
                obj.image = {};
                obj.image.opts = {image: obj.data.image, perturbation: perturbation};
                obj.image.mount = riot.mount("challenge", obj.image.opts)[0];
                obj.image.canvas = document.getElementById("canvas");
                console.log(obj.data.image.height);
            };

            obj.setPerturbation = function(perturbation){
                obj.image.opts.perturbation = perturbation;
                obj.image.mount.update();
            };

            obj.enableHuman = function(){
                return new Promise((resolve, reject) => {
                    obj.answers.opts.disabled = false;
                    obj.answers.opts.onselected = resolve;
                    obj.answers.mount.update();
                });
            };

            obj.setTimer = ms => new Promise(resolve => setTimeout(() => resolve("TIMEOUT"), ms));

            obj.removeAnswers = function(){
                obj.answers.mount.unmount(true);
            };

            obj.removeImage = function(){
                obj.image.mount.unmount(true);
            };

            obj.unmount = obj.removeImage;

            obj.fightOnce = async function(human, model, length){
                const machine = model.predictAndCheck(obj.image.canvas, obj.data.answers[obj.data.correct]);
                const timer = obj.setTimer(length);
                const [firstToFinish, result] = await Promise.race([human, machine, timer]);

                // human promise will only finish if correct answer was clicked -> no need to check the answer
                if ((firstToFinish === CONTESTANTS.HUMAN) || (firstToFinish === CONTESTANTS.TIMEOUT))
                    return firstToFinish;

                // machine was finished first, but it might have given the wrong answer
                // in this case it makes no sense to ask machine again (it will just give the same wrong answer again)
                // but human still gets chance to change their mind until timer runs out
                if (result === RESULTS.CORRECT)
                    return firstToFinish;
                else
                    return await Promise.race([human, timer]);

            };

            obj.fight = async function(human, model){
                // first loop through all perturbations (if any) and show each for short time to human and to machine
                if (obj.data.perturbations){
                    for (let i in obj.data.perturbations){
                        obj.setPerturbation(obj.data.perturbations[i]);
                        const winner = await obj.fightOnce(human, model, obj.PERTURBATION_TIMEOUT);
                        if (winner !== CONTESTANTS.TIMEOUT)
                            return winner;
                    }
                }
                // show the clean image for a longer time
                return await obj.fightOnce(human, model, obj.CLEAN_IMAGE_TIMEOUT);
            };


            obj.run = async function(model){
                await obj.loadData();

                // prepare the UI
                obj.showAnswers();
                await app.showInfoScreen("countdown", {length: 3}, "ontimeout");
                const initialPerturbation = obj.data.perturbations ? obj.data.perturbations[0]: null;
                obj.showImage(initialPerturbation);

                // fight!
                const human = obj.enableHuman();
                const winner = await obj.fight(human, model);

                // disable
                obj.removeAnswers();

                return winner;
            };


            return obj;
        };

        app.run = async function() {
            // animated intro
            await app.showInfoScreen("intro", {}, "onclick");

            // spinner while loading data
            const data = await app.loadData(opts);

            // rules
            await app.showInfoScreen("instructions", {text: "RULES"}, "onclick");

            // round1
            const round1 = app.initChallenge(data.rounds[0]);
            const winner1 = await round1.run(data.model);
            await app.showInfoScreen("instructions", {text: "ROUND1_"+winner1+"_WINS", overlay: true}, "onclick");
            round1.unmount();

            // round2
            const round2 = app.initChallenge(data.rounds[1]);
            const winner2 = await round2.run(model);
            await app.showInfoScreen("instructions", {text: "ROUND1_"+winner2+"_WINS", overlay: true}, "onclick");
            round2.unmount();

            // round3
            const round3 = app.initChallenge(data.rounds[2]);
            const winner3 = await round3.run(model);
            await app.showInfoScreen("instructions", {text: "ROUND1_"+winner3+"_WINS", overlay: true}, "onclick");
            round3.unmount();
        };


        app.on("mount", app.run);

    </script>

</app>
